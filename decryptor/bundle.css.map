{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte"
  ],
  "sourcesContent": [
    "<script>\n\tlet key = '';\n\tlet source = '';\n\tlet result = '';\n\n\tfunction decrypt() {\n\t\tif (key.length > 0 && key.length > 0) {\n\t\t\tresult = decryptByKey(key, source);\n\t\t} else {\n\t\t\tresult = 'введите данные'\n\t\t}\n\t}\n\n\tfunction decryptByKey(key, source) {\n\t\tlet sourceString = source;\n\t\tlet keyWord = key.toLowerCase();\n\t\tlet keyWordLength = keyWord.length;\n\t\tlet generatedString = '';\n\t\tlet keyArray = [];\n\n\t\t// sort functions\n\t\tfunction sortByCode( a, b ) {\n\t\t\tif (a.value.code < b.value.code) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (a.value.code > b.value.code) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((a.value.code === b.value.code) && (a.value.index > b.value.index)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tfunction sortByIndex( a, b ) {\n\t\t\tif ( a.value.index < b.value.index ){\n\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( a.value.index > b.value.index ){\n\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tfunction sortRank( a, b ) {\n\t\t\tif ( a.rank < b.rank ){\n\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( a.rank > b.rank ){\n\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (var i = 0; i < keyWordLength; i++) {\n\t\t\tkeyArray.push({\n\t\t\t\tkey: keyWord.charAt(i), \n\t\t\t\tvalue: {\n\t\t\t\t\tcode: keyWord.charCodeAt(i),\n\t\t\t\t\trank: null,\n\t\t\t\t\tindex: i\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tlet sortedKey = keyArray.sort(sortByCode);\n\t\tfor (var j = 0; j < sortedKey.length; j++) {\n\t\t\tsortedKey[j].value.rank = j;\n\t\t}\n\n\t\tsortedKey = sortedKey.sort(sortByIndex);\n\t\tlet keyRank = sortedKey.map((key, index) => {return {column: index, rank: key['value']['rank']}});\n\n\t\t// calculate filling\n\t\tlet columnFilling = [];\n\t\tlet completedLines = Math.floor(sourceString.length / keyWordLength);\n\t\tlet uncompletedLineLength = (sourceString.length % keyWordLength);\n\t\tlet allLines = (uncompletedLineLength > 0) ? completedLines + 1 : completedLines;\n\t\tlet sortedKeyRank = keyRank.sort(sortRank);\n\n\t\tlet decodedArray = [...Array( keyWordLength )].map( () =>\n\t\t\tArray( completedLines + uncompletedLineLength ).fill( null ).map(() =>\n\t\t\t\tnull));\n\t\t\n\t\tfunction letColumnHegiht(index, completedLines, uncompletedLineLength) {\n\t\t\tif (uncompletedLineLength) {\n\t\t\t\treturn (index <= (uncompletedLineLength - 1)) ? completedLines + 1 : completedLines\n\t\t\t} else {\n\t\t\t\treturn completedLines;\n\t\t\t}\n\t\t}\n\n\t\tfor (let z = 0; z <= keyWordLength -1 ; z++) {\n\t\t\tcolumnFilling.push({column: z, filling: letColumnHegiht(z, completedLines, uncompletedLineLength)})\n\t\t}\n\n\t\tlet splicePosition = 0;\n\t\tsortedKeyRank.map((key) => {\n\t\t\tlet virticalLength = columnFilling[key['column']]['filling'];\n\t\t\tlet column = columnFilling[key['column']]['column'];\n\t\t\tlet splicedString = sourceString.slice(splicePosition, splicePosition + virticalLength);\n\t\t\tsplicePosition = splicePosition + virticalLength;\n\n\t\t\tfor (let l = 0; l < splicedString.length; l++) {\n\t\t\t\tdecodedArray[column][l] = splicedString[l];\n\t\t\t}\n\t\t});\n\n\t\tdecodedArray = decodedArray.map(row => row.join(''));\n\t\tlet currentLine = 0;\n\n\t\tfor (let l = 0; l < allLines; l++) {\n\t\t\tfor (let c = 0; c < keyWordLength; c++) {\n\t\t\t\tif (decodedArray[c][l]) {\n\t\t\t\t\tgeneratedString+= decodedArray[c][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentLine++;\n\t\t}\n\n\t\treturn generatedString;\n\t}\n\n</script>\n\n<style>\n.materialize-textarea {\n\tmin-height: 180px;\n\toverflow: initial;\n}\n.output {\n\tword-break: break-all;\n}\n</style>\n\n<div class=\"container\">\n\t<div class=\"row\">\n\t\t<div class=\"col s12 m12\">\n\t\t\t<div class=\"card grey lighten-5\">\n\t\t\t\t<div class=\"card-content black-text\">\n\t\t\t\t\t<span class=\"card-title\">Кодировка методом перестановки</span>\n\t\t\t\t\t<input type=\"text\" bind:value={key} placeholder=\"введите ключ\">\n\t\t\t\t\t<textarea class=\"materialize-textarea\" placeholder=\"введите текст\" bind:value={source}></textarea>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"card-action\">\n\t\t\t\t\t<a href=\"/\" class=\"waves-effect waves-light btn\" on:click={decrypt}>расшифровать</a>\n\t\t\t\t\t<p class=\"output\">{result}</p>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>"
  ],
  "names": [],
  "mappings": "AA+HA,qBAAqB,eAAC,CAAC,AACtB,UAAU,CAAE,KAAK,CACjB,QAAQ,CAAE,OAAO,AAClB,CAAC,AACD,OAAO,eAAC,CAAC,AACR,UAAU,CAAE,SAAS,AACtB,CAAC"
}